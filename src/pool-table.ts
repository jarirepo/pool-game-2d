import * as Matter from 'matter-js';
import { Constants } from './constants';
import { mmult } from './vector3d';
import { Polyline } from './polyline';
import { Pocket } from './pocket';
import { Ball } from './ball';

// https://github.com/liabru/matter-js/issues/559
// window['decomp'] = require('poly-decomp');
import * as decomp from 'poly-decomp';
window['decomp'] = decomp;

const { tan } = Math;

export class PoolTable {

  width: number;
  footSpotPos = { x: 1 / 2, y: 1 / 4 };   // ball rack position on the pool table
  cueBallLinePos = 3 / 4;                 // cue-ball line position on the pool table
  imgData: ImageData;
  boundary: Path2D;
  cushionWidth: number;
  cushionBodies: Matter.Body[];
  cushionPaths: Path2D[];
  pockets: Pocket[];

  constructor(
    public readonly balls: Ball[],
    public readonly length: number,
    public readonly pocketRadius: number,
    public readonly options: Matter.IBodyDefinition
  ) {
    this.width = this.length / 2;
    this.cushionWidth = this.pocketRadius / 2;  // gives 45 degree angle

    const cushionRadius = this.cushionWidth * 2;  // < approx. max. 3 times the cusion width to prevent error
    const chamferLen = this.cushionWidth * Constants.SQRT_2;
    const chamferLineLen = cushionRadius / tan(3 * Constants.PI / 8);

    if (chamferLineLen > chamferLen) {
      console.log('Rail cushion radius is too large!');
    }

    // Polygon for a rail cushion segment. The remaining segments are generated by a sequence of rotatations.
    // The polylines must NOT be closed to prevent the Matter.js collision detector failure.

    // Non-filleted rail cushion
    // const cushionSegment = new Polyline(this.pocketRadius, 0)
    //   .lineTo(this.width - this.pocketRadius, 0)
    //   .lineTo(this.width - 1.5 * this.pocketRadius, this.cushionWidth)
    //   .lineTo(1.5 * this.pocketRadius, this.cushionWidth);

    // Filleted rail cushion
    const cushionSegment = new Polyline()
      .lineTo(this.width - 2 * this.pocketRadius, 0)
      .lineTo(this.width - 2 * this.pocketRadius - (chamferLen - chamferLineLen) * Constants.SQRT_2 / 2, (chamferLen - chamferLineLen) * Constants.SQRT_2 / 2)
      .arcTo(this.width - 2 * this.pocketRadius - this.cushionWidth - chamferLineLen, this.cushionWidth)
      .lineTo(this.cushionWidth + chamferLineLen, this.cushionWidth)
      .arcTo(this.cushionWidth - chamferLineLen * Constants.SQRT_2 / 2, this.cushionWidth - chamferLineLen * Constants.SQRT_2 / 2);

    console.log('Rail cushion polyline:', cushionSegment);
    
    const P1 = cushionSegment.p.map(v => [v.x, v.y, 1]);
    const R90 = [[0, 1, 0], [-1, 0, 0], [0, 0, 1]];
    const P2 = mmult(P1, R90);
    const P3 = mmult(P2, R90);
    const P4 = mmult(P3, R90);
    // console.log(P1, P1.length);

    const vertexSets1: Matter.Vector[][] = [ P1.map<Matter.Vector>(p => ({ x: p[0], y: -p[1] })) ];
    const vertexSets2: Matter.Vector[][] = [ P2.map<Matter.Vector>(p => ({ x: p[0], y: -p[1] })) ];
    const vertexSets3: Matter.Vector[][] = [ P3.map<Matter.Vector>(p => ({ x: p[0], y: -p[1] })) ];
    const vertexSets4: Matter.Vector[][] = [ P4.map<Matter.Vector>(p => ({ x: p[0], y: -p[1] })) ];

    this.cushionBodies = [
      Matter.Bodies.fromVertices(0, 0, vertexSets1, { ...this.options, label: `cushion-0` }),
      Matter.Bodies.fromVertices(0, 0, vertexSets2, { ...this.options, label: `cushion-1` }),
      Matter.Bodies.fromVertices(0, 0, vertexSets2, { ...this.options, label: `cushion-2` }),
      Matter.Bodies.fromVertices(0, 0, vertexSets3, { ...this.options, label: `cushion-3` }),
      Matter.Bodies.fromVertices(0, 0, vertexSets4, { ...this.options, label: `cushion-4` }),
      Matter.Bodies.fromVertices(0, 0, vertexSets4, { ...this.options, label: `cushion-5` })
    ];
    
    // Position the rail cushion segments since poly-decomp has translated them to their CoG.
    const cushionPos: Matter.Vector[] = [
      { x: this.width / 2, y: this.length - this.cushionWidth / 2 },
      { x: this.width - this.cushionWidth / 2, y: 0.75 * this.length },
      { x: this.width - this.cushionWidth / 2, y: 0.25 * this.length },
      { x: this.width / 2, y: this.cushionWidth / 2 },
      { x: this.cushionWidth / 2, y: 0.25 * this.length },
      { x: this.cushionWidth / 2, y: 0.75 * this.length }
    ];

    try {
      for (let i = 0; i < 6; i++) {
        Matter.Body.setPosition(this.cushionBodies[i], cushionPos[i]);
      }  
    } catch (e) {
      console.log('Failed to create bodies for cushion segments. Is the rail cushion radius too large?', e);
    }

    // Create pool table surface boundary for rendering. The world doesn't know about the table surface since we are in 2-d.
    // Path2D, https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D
    this.boundary = new Path2D();
    this.boundary.moveTo(pocketRadius, 0);
    this.boundary.lineTo(this.width - pocketRadius, 0);
    this.boundary.arc(this.width - pocketRadius, pocketRadius, pocketRadius, -Constants.HALF_PI, 0);
    this.boundary.lineTo(this.width, this.length - pocketRadius);
    this.boundary.arc(this.width - pocketRadius, this.length - pocketRadius, pocketRadius, 0, Constants.HALF_PI);
    this.boundary.lineTo(pocketRadius, this.length);
    this.boundary.arc(pocketRadius, this.length - pocketRadius, pocketRadius, Constants.HALF_PI, Constants.PI);
    this.boundary.lineTo(0, pocketRadius);
    this.boundary.arc(pocketRadius, pocketRadius, pocketRadius, Constants.PI, -Constants.HALF_PI);
        
    // Create rail cushion boundaries (Path2D objects) for rendering
    this.cushionPaths = this.cushionBodies.map(body => {
      const path = new Path2D();
      path.moveTo(body.vertices[0].x, body.vertices[0].y);
      for (let i = 1; i < body.vertices.length; i++) {
        path.lineTo(body.vertices[i].x, body.vertices[i].y);
      }
      return path;
    });

    // Create pockets as detectors. These trigger collision events.
    // https://github.com/liabru/matter-js/blob/master/examples/sensors.js    
    this.pockets = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: .5 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: 0, y: .5 }]
      .map<Pocket>((p, i) => {
        const body = Matter.Bodies.circle(p.x * this.width, p.y * this.length, this.pocketRadius,
          { isSensor: true, isStatic: true, label: `pocket-${i}` }
        );
        return new Pocket(this.pocketRadius, body);
      });
  }

  /**
   * Returns true if all non-pocketed balls have stopped rolling
   */
  hasSettled(): boolean {
    return this.balls
      .filter(ball => !ball.isPocketed)
      .map(ball => !ball.isRolling())
      .reduce((result, val) => result && val, true);
  }

  render(ctx: CanvasRenderingContext2D) {
    // Pool table surface    
    ctx.fillStyle = 'rgba(0,80,0,1)'; 
    ctx.fill(this.boundary);
    // Foot spot (rack position)
    ctx.beginPath();
    ctx.arc(this.width / 2, this.length / 4, 10, 0, Constants.TWO_PI);
    ctx.fillStyle = 'rgba(0,64,0,.8)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.width / 2, this.length / 4, 5, 0, Constants.TWO_PI);
    ctx.fillStyle = 'rgba(0,96,0,1)';
    ctx.fill();
    // Cue-ball line
    ctx.beginPath();
    ctx.moveTo(this.cushionWidth, this.length * 0.75);
    ctx.lineTo(this.width - this.cushionWidth, this.length * 0.75);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,64,0,.8)';
    ctx.stroke();
    // Pockets
    ctx.beginPath();
    this.pockets.forEach(pocket => pocket.render(ctx));
    ctx.fill();
    // Rail cushions
    ctx.fillStyle = 'green';
    this.cushionPaths.forEach((path, i) => {
      // ctx.fillStyle = (i === 0) ? 'yellow' : 'green';
      ctx.fill(path)
    });
  }
}
