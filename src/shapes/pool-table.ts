import * as Matter from 'matter-js';
import { Constants } from '../constants';
import { Vector3D, Matrix4, applyTransform } from '../vector3d';
import { Polyline } from '../polyline';
import { Pocket } from './pocket';
import { RailCushion } from './rail-cushion';
import { Rack } from '../rack';
import { Ball } from './ball';
import { IShape } from './shape';
import { Viewport } from '../viewport';

// https://github.com/liabru/matter-js/issues/559
// window['decomp'] = require('poly-decomp');
import * as decomp from 'poly-decomp';
window['decomp'] = decomp;

const { abs, tan, max, sqrt, atan2, random } = Math;

export class PoolTable implements IShape {

  public readonly isStatic = true;
  public readonly modified = false;

  width: number;
  footSpotPos = { x: 1 / 2, y: 1 / 4 };   // ball rack position on the pool table
  cueBallLinePos = 3 / 4;                 // cue-ball line position on the pool table
  imgData: ImageData;
  boundary: Path2D;
  railCushions: RailCushion[] = [];
  pockets: Pocket[];
  cushionWidth: number;
  cushionBodies: Matter.Body[];
  cushionPaths: Path2D[];

  /** Polyline for the table surface */
  private tablePoly: Polyline;
  
  /** Object Coordinate System, relative to the World Coordinate System (WSC) */
  ocs: Matrix4 = {
    m00: 1, m01: 0, m02: 0, m03: 0,
    m10: 0, m11: 1, m12: 0, m13: 0,
    m20: 0, m21: 0, m22: 1, m23: 0,
    m30: 0, m31: 0, m32: 0, m33: 1
  };

  constructor(
    public readonly rack: Rack,
    public readonly balls: Ball[],
    public readonly length: number,
    public readonly pocketRadius: number,
    public readonly options: Matter.IBodyDefinition
  ) {
    this.width = this.length / 2;
    this.cushionWidth = this.pocketRadius / 2;  // gives 45 degree angle

    const cushionRadius = this.cushionWidth * 2;  // < approx. max. 3 times the cusion width to prevent error
    const chamferLen = this.cushionWidth * Constants.SQRT_2;
    const chamferLineLen = cushionRadius / tan(3 * Constants.PI / 8);

    if (chamferLineLen > chamferLen) {
      console.log('Rail cushion radius is too large!');
    }

    // Set Object Coordinate System (OCS)
    this.ocs.m00 = 0; this.ocs.m01 = -1; this.ocs.m02 = 0;  // ex: (0,-1,0)
    this.ocs.m10 = 1; this.ocs.m11 = 0; this.ocs.m12 = 0;   // ey: (1,0,0)
    this.ocs.m20 = 0; this.ocs.m21 = 0; this.ocs.m22 = 1;   // ez: (0,0,1)
    this.ocs.m30 = 50; this.ocs.m31 = this.width + 50; this.ocs.m32 = 0;  // origin

    // Polygon for the pool table surface
    this.tablePoly = new Polyline(this.pocketRadius, 0)
      .lineTo(this.width - this.pocketRadius, 0)
      .arcTo(this.width, pocketRadius)
      .lineTo(this.width, this.length - this.pocketRadius)
      .arcTo(this.width - this.pocketRadius, this.length)
      .lineTo(this.pocketRadius, this.length)
      .arcTo(0, this.length - this.pocketRadius)
      .lineTo(0, this.pocketRadius)
      .arcTo(this.pocketRadius, 0);    
    this.boundary = this.tablePoly.toPath2D();

    // Rail cushion segment, relative to the pool table.
    // The remaining segments are generated by cloning and a sequence of rotatations and translations.
    let railCushion = new RailCushion({
      length: this.width - 2 * this.pocketRadius,
      width: this.pocketRadius / 2,
      radius: this.pocketRadius
    });
    railCushion.moveTo(this.pocketRadius, 0);
    this.railCushions.push(railCushion);
    for (let i = 0; i < 5; i++) {
      railCushion = railCushion.clone();
      if (i === 0 || i === 2 || i === 3) {
        railCushion.rotateZ(Constants.HALF_PI);
      }
      this.railCushions.push(railCushion);
    }
    // Positioning
    [
      { x: this.pocketRadius, y: 0 },
      { x: this.width, y: this.pocketRadius },
      { x: this.width, y: this.length / 2 + this.pocketRadius },
      { x: this.width - this.pocketRadius, y: this.length },
      { x: 0, y: this.length - this.pocketRadius },
      { x: 0, y: this.length / 2 - this.pocketRadius }
    ]
    .forEach((p, i) => this.railCushions[i].moveTo(p.x, p.y, 10));

    /**
     * Create cushion segment bodies for the physics world
     * The polylines must NOT be closed to prevent the Matter.js collision detector failure.
     * Requires re-positioning since "poly-decomp" has translated them to their CoG.
     */
    this.cushionBodies = this.railCushions.map<Matter.Body>((obj, i) => {
      // Transform vertices to the pool table
      const P = obj.polyline.p
        .filter((p, k) => k < obj.polyline.p.length - 1)
        .map(p => applyTransform(p, obj.ocs))
        .map(p => ({ x: p.x, y: p.y }));
      const body = Matter.Bodies.fromVertices(0, 0, [ P ], { ...this.options, label: `cushion-${i}` });
      return body;
    });

    // Re-positioning
    const cushionPos: Matter.Vector[] = [
      { x: this.width / 2, y: this.cushionWidth / 2 },
      { x: this.width - this.cushionWidth / 2, y: 0.25 * this.length },
      { x: this.width - this.cushionWidth / 2, y: 0.75 * this.length },
      { x: this.width / 2, y: this.length - this.cushionWidth / 2 },
      { x: this.cushionWidth / 2, y: 0.75 * this.length },
      { x: this.cushionWidth / 2, y: 0.25 * this.length }
    ];
    try {
      for (let i = 0; i < 6; i++) {
        Matter.Body.setPosition(this.cushionBodies[i], cushionPos[i]);
      }  
    } catch ( e ) {
      console.log('Failed to create bodies for cushion segments. Is the rail cushion radius too large?', e);
    }

    // Create rail cushion boundaries (Path2D objects) for rendering
    // Path2D, https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D
    this.cushionPaths = this.cushionBodies.map(body => {
      const path = new Path2D();
      path.moveTo(body.vertices[0].x, body.vertices[0].y);
      for (let i = 1; i < body.vertices.length; i++) {
        path.lineTo(body.vertices[i].x, body.vertices[i].y);
      }
      return path;
    });

    // Create pool table pockets, relative to the pool table.
    // Defined as Matter.js detectors (these will trigger collision events).
    // https://github.com/liabru/matter-js/blob/master/examples/sensors.js
    const pocketPos = [
      { u: 0, v: 0 },
      { u: 1, v: 0 },
      { u: 1, v: .5 },
      { u: 1, v: 1 },
      { u: 0, v: 1 },
      { u: 0, v: .5 }
    ];
    this.pockets = pocketPos
      .map<Vector3D>(p => ({ x: p.u * this.width, y: p.v * this.length, z: 5 }))  // local coords.
      .map<Pocket>((p, i) => {
        const body = Matter.Bodies.circle(p.x, p.y, this.pocketRadius, { isSensor: true, isStatic: true, label: `pocket-${i}` });
        const pocket = new Pocket({ radius: this.pocketRadius}, body);
        pocket.ocs.m30 = p.x;
        pocket.ocs.m31 = p.y;
        pocket.ocs.m32 = p.z;
        Matter.Body.setPosition(body, { x: p.x, y: p.y });
        return pocket;
      });

    console.log('Table surface polyline:', this.tablePoly);
    console.log('Rail cushions:', this.railCushions);
    console.log('Pockets:', this.pockets);
  }

  public init(): void {
    // Stack balls 1-15 in the triangular rack (with the rack's apex at the foot spot)
    this.rack.setup();
    this.rack.slots.forEach(slot => {
      const ball = this.balls[slot.ballId];
      // Ball's position on the pool table
      const Pocs: Vector3D = {
        x: 0.5 * this.width + slot.u * ball.radius,
        y: 0.75 * this.length + slot.v * ball.radius,
        z: ball.radius
      };
      ball.moveTo(Pocs.x, Pocs.y, Pocs.z);
    });
    // Place the cue-ball on the cue-ball line on the pool table
    const cueBall = this.balls.find(ball => ball.value === 0);
    cueBall.moveTo(this.width / 2 + (2 * random() -1) * cueBall.radius, 0.25 * this.length, cueBall.radius);
  }

  /** Returns true if all non-pocketed balls have stopped rolling */
  public hasSettled(): boolean {
    // return this.balls
    //   .filter(ball => !ball.isPocketed)
    //   .map(ball => !ball.isRolling())
    //   .reduce((result, val) => result && val, true);
    const weight = this.calcPerceivedSettling();
    return weight < 5;
  }
  
  /**
   * 
   */
  private calcPerceivedSettling(): number {
     // Include all non-pocketed balls
     const activeBalls = this.balls.filter(ball => !ball.isPocketed);
    let wMax = 0;

    for (let i = 0; i < activeBalls.length; i++) {
      const ballA = activeBalls[i];
      const rb = ballA.radius;
      const b = ballA.body.position;
      const vA = ballA.body.velocity;
      const vAn = Matter.Vector.normalise(vA);
      const vmag = (ballA.body.speed < .1) ? 0 : ballA.body.speed;
      const W: { angle: number, distance: number, speed: number }[] = [];

      for (let pocket of this.pockets) {
        const p = pocket.body.position;
        const u = Matter.Vector.sub(p, b);
        const d2 = Matter.Vector.magnitudeSquared(u) - this.pocketRadius * this.pocketRadius;
        const un = Matter.Vector.normalise(u);
        let cosTheta = Matter.Vector.dot(vAn, un).valueOf();
        if (vmag === 0) {
          cosTheta = 0;
        }
        if (cosTheta > 0) {
          // Pocket is in front of the ball
          W.push({
            angle: cosTheta,
            distance: 1 / (1 + sqrt(d2)),
            speed: vmag
          });
        } else {
          W.push({ angle: 0, distance: 0, speed: 0 });
        }
      }

      const Wt: number[] = [];

      if (i < activeBalls.length - 1) {
        // Check potential collisions with balls i+1, i+2, ...
        // Wt will contain the weights based on the estimated time to potential collisions

        innerLoop: for (let j = i + 1; j < activeBalls.length; j++) {
          const ballB = activeBalls[j];
          const vB = ballB.body.velocity;
          const u = Matter.Vector.sub(ballB.body.position, ballA.body.position);
          const umag = Matter.Vector.magnitude(u);
          const alpha = atan2(u.y, u.x);
          const va = Matter.Vector.rotate(vA, -alpha);
          const vb = Matter.Vector.rotate(vB, -alpha);

          let vax = (abs(va.x) < 1) ? 0 : va.x;
          let vay = (abs(va.y) < 1) ? 0 : va.y;
          let vbx = (abs(vb.x) < 1) ? 0 : vb.x;
          let vby = (abs(vb.y) < 1) ? 0 : vb.y;

          let tc = 0; // estimated time to collision between balls A and B

          if (vax === 0 && vbx === 0) {
            continue innerLoop;
          }
          if (vax === 0 && vay === 0) {
            [ vax, vbx ] = [ vbx, vax ];
            [ vay, vby ] = [ vby, vay ];
          }
          if (vax < 0 && vbx === 0) {
            continue innerLoop;
          }
          if (vax > 0 && vbx === 0) {
            tc = (umag - ballA.radius - ballB.radius) / vax;
          }
          if (vax > 0 && vbx > 0) {
            if (vax > vbx) {
              // How long time for ball A to catch ball B
              tc = (ballA.radius + umag) / (vax - vbx);
              // Check if Ball B can escape the collision corridor
              if (vby !== 0) {
                const t2r = 2 * ballB.radius / abs(vby);
                if (t2r < tc) {
                  // console.log(`Ball ${ballB.value} will escape the collision corridor`);
                  continue innerLoop;
                }
              }
            } else if (vax < vbx) {
              // How long time for ball B to catch ball A
              tc = (ballB.radius + umag) / (vbx - vax);
              // Check if Ball A can escape the collision corridor
              if (vay !== 0) {
                const t2r = 2 * ballA.radius / abs(vay);
                if (t2r < tc) {
                  // console.log(`Ball ${ballA.value} will escape the collision corridor`);
                  continue innerLoop;
                }
              }
            }
          } else if ((vax > 0 && vbx) < 0 || (vax < 0 && vbx > 0)) {
            /**
             * s(i) = vx(i) * tc
             * s(j) = vx(j) * tc
             * d(i) = s(i) + s(j) = ||p(i)-p(j)||+r(i)+r(j)
             * tc = d(i) / |vx(i)| + |vx(j)|
             */
            tc = umag / (abs(vax) + abs(vbx));
            // Check if ball A or ball B can escape the collision corridor before a collision occurs
            if (abs(vay) > 0) {
              const t = 2 * ballA.radius / abs(vay);
              if (t < tc) {
                // console.log(`Ball ${ballA.value} will escape the collision corridor`);
                continue innerLoop;
              }
            }
            if (abs(vby) > 0) {
              const t = 2 * ballB.radius / abs(vby);
              if (t < tc) {
                // console.log(`Ball ${ballA.value} will escape the collision corridor`);
                continue innerLoop;
              }
            }
          }
          if (tc > 0) {
            // console.log({ vax, vay, vbx, vby, tc, Wt: 1 / (1 + 1e-3 * tc) });
            // console.log({ ballA: ballA.value, ballB: ballB.value, tc, Wt: 1 / (1 + 1e-3 * tc) });
            const wt = 1 / (1 + 1e-3 * tc);
            Wt.push(wt);
          }
        }
      }

      // Weighting
      if (W.length > 0) {
        // console.log(`Ball ${ball.value} weights:`, W);
        let w = W
          .map(weight => (1 + weight.speed) * (weight.angle + weight.distance))
          .reduce((result, val) => result + val, 0);
          // console.log(`Ball ${ball.value} weights:`, W, max(w));
        if (Wt.length > 0) {
          // Get max weight from the ball collision checks
          const wt = max(...Wt);
          w *= wt;
        }
        if (ballA.activity.length > 200) {
          ballA.activity.splice(0, 1);
        }
        ballA.activity.push(w);
        const m = max(w);
        if (m > wMax) {
          wMax = m;
        }
      }
    }
    return wMax;
  }

  public render(vp: Viewport, T: Matrix4): void {
    // Pool table surface
    vp.context.beginPath();
    vp.context.fillStyle = 'rgba(0,80,0,1)'; 
    vp.context.fill(this.boundary);
    // Foot spot (rack position)
    vp.context.beginPath();
    vp.context.arc(0.5 * this.width, 0.75 * this.length, 12, 0, Constants.TWO_PI);
    vp.context.fillStyle = 'rgba(0,64,0,.8)';
    vp.context.fill();
    vp.context.beginPath();
    vp.context.arc(0.5 * this.width, 0.75 * this.length, 6, 0, Constants.TWO_PI);
    vp.context.fillStyle = 'rgba(0,96,0,1)';
    vp.context.fill();
    // Cue-ball line
    vp.context.beginPath();
    vp.context.moveTo(this.cushionWidth, 0.25 * this.length);
    vp.context.lineTo(this.width - this.cushionWidth, 0.25 * this.length);
    vp.context.lineWidth = 6;
    vp.context.strokeStyle = 'rgba(0,64,0,.8)';
    vp.context.stroke();
  }
}
